let handlerCode=new Map([["instantiate",'\nself.handler=async function(e,t){let r=this;const o=class{constructor(e){this.name=e}getObjectStore(e){return r.idb.db.transaction(this.name,e).objectStore(this.name)}iterate_db(e,t,r){let o;t||"function"!=typeof e||(t=e,e=null);let n="";e&&(o=IDBKeyRange.lowerBound(e),n=e.toString()+","),this.getObjectStore().openCursor(o).onsuccess=function(o){let i=o.target.result;if(i){let o=i.value;if(e){let e=o.id.toString()+",";""!==n&&e.startsWith(n)?(t&&t(o.id,o.value),i.continue()):r&&"function"==typeof r&&r()}else t&&t(o.id,o.value),i.continue()}else r&&"function"==typeof r&&r()}}iterate(e,t){t||"function"!=typeof e||(t=e,e=null);let r=this;return new Promise(o=>{r.iterate_db(e,t,function(){o()})})}async clearByKey(e){let t=this;await this.iterate(e,async function(e){await t.delete(e)})}clear_db(e){if(!_worker.idb.db)return e({error:"clear() Error: Database has not been opened"});let t=this.getObjectStore("readwrite").clear();t.onsuccess=function(){e({ok:!0})},t.onerror=function(){e({error:t.error})}}clear(){let e=this;return new Promise(t=>{e.clear_db(function(e){t(e)})})}put_item(e,t,o){if(!r.idb.db)return o({error:"addItem Error: Database has not been opened"});o||(o=t,t=e,e=null);let n=this.getObjectStore("readwrite").put(t);n.onsuccess=function(){r.emit("putCommitted",t),o({key:n.result})},n.onerror=function(){o({error:n.error})}}put(e,t){t||(t=e,e=null);let r=this;return new Promise(o=>{r.put_item(e,t,function(e){o(e)})})}delete_item(e,t){if(!r.idb.db)return t({error:"delete_item Error: Database has not been opened"});let o=this.getObjectStore("readwrite").delete(e);o.onsuccess=function(){r.emit("deleteCommitted",e),t({ok:!0})},o.onerror=function(){t({error:o.error})}}delete(e){let t=this;return new Promise(r=>{t.delete_item(e,function(e){r(e)})})}};function n(e,t){let o={};t?o.keyPath=t:o.autoIncrement=!0,r.idb.objectStores.set(e,o)}function i(e,t){if(!r.idb.store)return t({error:"Open Database Error: Store Name not defined"});t||(t=e,e=null);let n=indexedDB.open(r.idb.store,e);n.onsuccess=function(e){r.idb.db=e.target.result,r.emit("databaseOpen",r.idb.db),t({db:r.idb.db})},n.onerror=function(e){t({error:e.target.errorCode})},n.onupgradeneeded=function(e){r.idb.db=e.target.result,function(){if(r.idb)for(const[e,t]of r.idb.objectStores.entries())r.idb.db.objectStoreNames.contains(e)||(r.idb.db.createObjectStore(e,t),r.idb.stores[e]||(r.idb.stores[e]=new o(e)))}()}}async function s(e){return new Promise(t=>{i(e,function(e){t(e)})})}r.idb||(this.idb={objectStores:new Map,stores:{},store:e.idb_name});let d=e.objectStores||[];for(const e of d)n(e,"id");await s();let a=!1;for(const e of r.idb.objectStores.keys())r.idb.db.objectStoreNames.contains(e)||(a=!0),r.idb.stores[e]=new o(e);if(a){let e=r.idb.db.version+1;r.idb.db.close(),await s(e),r.emit("databaseReady"),t({db_ready:!0})}else this.emit("databaseReady"),t({db_ready:!0})};\n  '],["restore",'\nself.handler=async function(e,t){let a={},r=this;if(r.idb&&r.idb.db){let i=e.storeName;r.idb.storeName=e.storeName,await r.idb.stores[i].iterate(function(e,t){var r=a;let i;e.forEach(function(a,s){let o=!1;if(Array.isArray(a)&&(o=!0,a=+a[0]),0===s&&(i=a),s===e.length-1)r[a]=t;else{let t=e[s+1];Array.isArray(t)?void 0===r[a]&&(r[a]=[]):void 0===r[a]&&(r[a]={}),r=r[a]}})}),t({obj:a})}else t({error:"Database not instantiated"})};\n  '],["put",'\nself.handler=async function(e,a){let t=this;if(t.idb&&t.idb.db){let i=e.key,l=e.value,s=t.idb.stores[t.idb.storeName];await s.clearByKey(i);let d={id:i,value:l};await s.put(d),a({ok:!0})}else a({error:"Database not instantiated"})};\n  '],["delete",'\nself.handler=async function(e,t){let a=this;if(a.idb&&a.idb.db){let i=e.key,s=a.idb.stores[a.idb.storeName];await s.clearByKey(i),t({ok:!0})}else t({error:"Database not instantiated"})};\n  ']]),DPP=class{constructor(e){let t=e.logging||!1,r=e.QOper8,i=e.qOptions||{},s=e.idb_name||"DPP",o=e.storeName||"DPP_Store";this.name="DPP-Q",this.build="2.2",this.buildDate="2 August 2022",this.listeners=new Map,this.logging=t||!1,this.storeName=o,this.idb_name=s,this.QOper8=new r({poolSize:1,logging:i.logging,workerInactivityCheckInterval:i.workerInactivityCheckInterval||60,workerInactivityLimit:i.workerInactivityLimit||60});let n=new Map;for(const[e,t]of handlerCode)n.set(e,this.QOper8.createUrl(t));this.QOper8.handlersByMessageType=n;let a=this;this.deepProxy=class{constructor(e,t){return this._preproxy=new WeakMap,this._handler=t,this.proxify(e,[])}makeHandler(e){let t=this;return{set:(r,i,s,o)=>("object"==typeof s&&(s=t.proxify(s,[...e,i])),r[i]=s,t._handler.set&&t._handler.set(r,[...e,i],s,o),!0),deleteProperty(r,i){if(Reflect.has(r,i)){t.unproxy(r,i);let s=Reflect.deleteProperty(r,i);return s&&t._handler.deleteProperty&&t._handler.deleteProperty(r,[...e,i]),s}return!0}}}unproxy(e,t){this._preproxy.has(e[t])&&(e[t]=this._preproxy.get(e[t]),this._preproxy.delete(e[t]));for(let r of Object.keys(e[t]))"object"==typeof e[t][r]&&this.unproxy(e[t],r)}proxify(e,t){for(let r of Object.keys(e))"object"==typeof e[r]&&(e[r]=this.proxify(e[r],[...t,r]));let r=new Proxy(e,this.makeHandler(t));return this._preproxy.set(r,e),r}},this.persistAs=class{constructor(){this.storeName=a.storeName,this.persist=!0}async proxy(e){let t=this,r=(this.storeName,new a.deepProxy({},{async set(e,r,i,s){if(!t.persist)return;a.logMessage("proxy set called with prop = "+JSON.stringify(r));let o=t.receiver,n=!1;function l(t,i){1===t.length&&(e[r]=i),a.emit("save",i);let s={type:"put",key:t,value:i};a.QOper8.message(s)}return r.forEach(function(e,t){o=o[e],n&&(r[t]=[e]),n=Array.isArray(o)}),"object"==typeof i&&async function e(t,r){a.logMessage("getProps called for "+JSON.stringify(t)),a.logMessage("obj="+JSON.stringify(r));let i={type:"delete",key:t};a.QOper8.message(i);let s=Array.isArray(r);for(let[i,o]of Object.entries(r)){s&&(i=[i]);let r=t.slice();r.push(i),"object"!=typeof o?l(r,o):e(r,o)}}(r,i),["string","number","boolean","symbol","bigint"].includes(typeof i)&&l(r,i),a.emit("proxy_set_completed",r),!0},deleteProperty(e,r){let i=t.receiver,s=!1;r.forEach(function(e,t){i=i[e],s&&(r[t]=[e]),s=Array.isArray(i)}),a.emit("delete",r);let o={type:"delete",key:r};a.QOper8.message(o)}}));return this.receiver=r,"new"!==e?await this.restore():await this.clear(),r}async clear(){await this.store.clear()}async restore(){let e={type:"restore",storeName:this.storeName},t=await a.QOper8.send(e);this.persist=!1;for(let e in t.obj)this.receiver[e]=t.obj[e];this.persist=!0}}}static async create(e){if(!e.QOper8){let{QOper8:t}=await import("https://robtweed.github.io/QOper8/src/QOper8.min.js");e.QOper8=t}return new DPP(e)}async start(e){let t={type:"instantiate",idb_name:this.idb_name,objectStores:[this.storeName]};return this.QOper8.message(t),await(new this.persistAs).proxy(e)}isEmpty(e){for(const t in e)return!1;return!0}on(e,t){this.listeners.has(e)||this.listeners.set(e,t)}off(e){this.listeners.has(e)&&this.listeners.delete(e)}emit(e,t){if(this.listeners.has(e)){this.listeners.get(e).call(this,t)}}logMessage(e){this.logging&&console.log(Date.now()+": "+e)}};export{DPP};