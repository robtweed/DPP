let handlerCode=new Map([["instantiate",'self.handler=async function(e,t){let r,n=this;const o=class{constructor(e,t){this.name=e;let o,i=!1,s=!1;t?(o=t,i=!0):s=!0;let a=this;this.isAuthenticated=function(){return i},this.setSignature=async function(e){if(i){let t={id:["signature"],value:o.getHash(r)};await a.put(t,void 0,e)}},this.isValidSignature=function(e){return e===o.getHash(r)},this.setReady=function(e){e===r&&(s=!0)},this.isReady=function(e){return e===r&&s},this.retrieve=async function(e){if(e!==r)return{};let t=[];await a.iterate(function(e,r){t.push({key:e,value:r})});let n=[];if(i&&s)for(let e=0;e<t.length;e++){let r=t[e],i=r.value;"signature"!==r.key[0]&&(i=await o.decrypt(i),n.push({key:r.key,value:i}))}else n=t;let c={};return n.forEach(function(e){let t=e.key,r=e.value;var n=c;t.forEach(function(e,o){if(Array.isArray(e)&&(e=+e[0]),o===t.length-1)n[e]=r;else{let r=t[o+1];Array.isArray(r)?void 0===n[e]&&(n[e]=[]):void 0===n[e]&&(n[e]={}),n=n[e]}})}),c},this.put_item=async function(e,t,r){if(i&&s&&(t.value=await o.encrypt(t.value)),!self.idb.db)return r({error:"addItem Error: Database has not been opened"});r||(r=t,t=e,e=null);let a=this.getObjectStore("readwrite").put(t);a.onsuccess=function(){n.emit("putCommitted",t),r({key:a.result})},a.onerror=function(){r({error:a.error})}}}getObjectStore(e){return self.idb.db.transaction(this.name,e).objectStore(this.name)}isValidToken(e){return e===r}iterate_db(e,t,r){let n;t||"function"!=typeof e||(t=e,e=null);let o="";e&&(n=IDBKeyRange.lowerBound(e),o=e.toString()+",");this.getObjectStore().openCursor(n).onsuccess=function(n){let i=n.target.result;if(i){let n=i.value,s=n.id,a=n.value;if(e){let e=s.toString()+",";""!==o&&e.startsWith(o)?(t&&t(s,a),i.continue()):r&&"function"==typeof r&&r()}else t&&t(s,a),i.continue()}else r&&"function"==typeof r&&r()}}iterate(e,t){t||"function"!=typeof e||(t=e,e=null);let r=this;return new Promise(n=>{r.iterate_db(e,t,function(){n()})})}async clearByKey(e,t){if(t!==r)return!1;let n=this;await this.iterate(e,async function(e){await n.delete(e)})}clear_db(e){if(!self.idb.db)return e({error:"clear() Error: Database has not been opened"});let t=this.getObjectStore("readwrite").clear();t.onsuccess=function(){e({ok:!0})},t.onerror=function(){e({error:t.error})}}clear(){let e=this;return new Promise(t=>{e.clear_db(function(e){t(e)})})}count_items(e){if(!self.idb.db)return e({error:"count Error: Database has not been opened"});let t=this.getObjectStore("readonly").count();t.onsuccess=function(){e(t.result)},t.onerror=function(){e({error:t.error})}}count(){let e=this;return new Promise(t=>{e.count_items(function(e){t(e)})})}put(e,t,n){if(n!==r)return!1;t||(t=e,e=null);let o=this;return new Promise(async r=>{await o.put_item(e,t,function(e){r(e)})})}get_item(e,t){if(!self.idb.db)return t({error:"get_item Error: Database has not been opened"});let r=this.getObjectStore("readonly").get(e);r.onsuccess=function(){t(r.result)},r.onerror=function(){t({error:r.error})}}get(e){let t=this;return new Promise(r=>{t.get_item(e,function(e){r(e)})})}delete_item(e,t){if(!self.idb.db)return t({error:"delete_item Error: Database has not been opened"});let r=this.getObjectStore("readwrite").delete(e);r.onsuccess=function(){n.emit("deleteCommitted",e),t({ok:!0})},r.onerror=function(){t({error:r.error})}}delete(e){let t=this;return new Promise(r=>{t.delete_item(e,function(e){r(e)})})}};async function i(e,t,r){const n=await crypto.subtle.encrypt({iv:r,name:"AES-GCM"},t,(new TextEncoder).encode(e));var o;return o=n,btoa(String.fromCharCode(...new Uint8Array(o)))}async function s(e,t,r){let n=function(e){let t=atob(e),r=t.length,n=new Uint8Array(r);for(let e=0;e<r;e++)n[e]=t.charCodeAt(e);return n.buffer}(e),o=await crypto.subtle.decrypt({iv:r,name:"AES-GCM"},t,n);return o=(new TextDecoder).decode(o)}function a(e,t){let r={};t?r.keyPath=t:r.autoIncrement=!0,self.idb.objectStores.set(e,r)}function c(e,t,r){if(!self.idb.store)return r({error:"Open Database Error: Store Name not defined"});r||(r=e,e=null);let i=indexedDB.open(self.idb.store,e);i.onsuccess=function(e){self.idb.db=e.target.result,n.emit("databaseOpen",self.idb.db),r({db:self.idb.db})},i.onerror=function(e){r({error:e.target.errorCode})},i.onupgradeneeded=function(e){self.idb.db=e.target.result,function(e){if(self.idb)for(const[t,r]of self.idb.objectStores.entries())self.idb.db.objectStoreNames.contains(t)||(self.idb.db.createObjectStore(t,r),self.idb.stores[t]||(self.idb.stores[t]=new o(t,e)))}(t)}}async function u(e,t){return new Promise(r=>{c(e,t,function(e){r(e)})})}let l;if(self.idb||(self.idb={objectStores:new Map,stores:{},store:e.idb_name}),r=([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16)),e.qoper8&&e.qoper8.auth){let n=e.qoper8.auth;if(!n.username||""===n.username)return t({error:"Authentication credentials are missing"});if(!n.password||""===n.password)return t({error:"Authentication credentials are missing"});let o=await async function(e,t){const r=e=>new Uint8Array([...unescape(encodeURIComponent(e))].map(e=>e.charCodeAt(0))),n=r(t),o=r(e),i=await crypto.subtle.importKey("raw",n,{name:"HMAC",hash:"SHA-256"},!0,["sign"]),s=await crypto.subtle.sign("HMAC",i,o);return btoa(String.fromCharCode(...new Uint8Array(s)))}(n.username,n.password),a=await async function(e){let t=await async function(e){return await crypto.subtle.digest("SHA-256",(new TextEncoder).encode(e))}(e);return await crypto.subtle.importKey("raw",t,{name:"AES-GCM"},!1,["encrypt","decrypt"])}(n.username+":"+n.password);l={getHash:function(e){return e===r&&o},encrypt:async function(e){let t=crypto.getRandomValues(new Uint8Array(12));return{encrypt:await i(e,a,t),iv:t}},decrypt:async function(e){return await s(e.encrypt,a,e.iv)}}}let d=e.objectStores||[];for(const e of d)a(e,"id");await u(void 0,l);let f=!1;for(const e of self.idb.objectStores.keys())self.idb.db.objectStoreNames.contains(e)||(f=!0),self.idb.stores[e]=new o(e,l);if(f){let e=self.idb.db.version+1;self.idb.db.close(),await u(e,l),n.emit("databaseReady"),t({db_ready:!0,qoper8:{token:r}})}else this.emit("databaseReady"),t({db_ready:!0,qoper8:{token:r}})};'],["restore",'self.handler=async function(e,t){let a="";e.qoper8&&e.qoper8.token&&(a=e.qoper8.token);if(self.idb&&self.idb.db){let i=e.storeName;self.idb.storeName=e.storeName;let r=self.idb.stores[i];if(!r.isValidToken(a))return t({error:"Invalid access attempt"});let s={};if(e.clear)await r.iterate(async function(e,t){await r.clearByKey(e,a)});else{if(0===await r.count()&&r.isAuthenticated())await r.setSignature(a),r.setReady(a);else{if(r.isAuthenticated()){let e=await r.get(["signature"]);if(!e)return t({error:"The requested store is not encrypted, but you have supplied authentication credentials"});if(!r.isValidSignature(e.value))return t({error:"Invalid authentication credentials for specified store"});r.setReady(a)}delete(s=await r.retrieve(a)).signature}}t({obj:s})}else t({error:"Database not instantiated"})};'],["put",'self.handler=async function(e,a){let t="";e.qoper8&&e.qoper8.token&&(t=e.qoper8.token);if(self.idb&&self.idb.db){let i=e.key,r=e.value,s=self.idb.stores[self.idb.storeName];if(!s.isValidToken(t))return a({error:"Invalid access attempt"});if(!s.isReady(t))return a({error:"Database not initialised for access"});await s.clearByKey(i,t);let o={id:i,value:r};await s.put(o,void 0,t),a({ok:!0})}else a({error:"Database not instantiated"})};'],["delete",'self.handler=async function(e,t){let a="";e.qoper8&&e.qoper8.token&&(a=e.qoper8.token);if(self.idb&&self.idb.db){let r=e.key,s=self.idb.stores[self.idb.storeName];if(!s.isValidToken(a))return t({error:"Invalid access attempt"});await s.clearByKey(r,a),t({ok:!0})}else t({error:"Database not instantiated"})};']]),DPP=class{constructor(e){let t=e.logging||!1,r=e.QOper8,n=e.qOptions||{},i=e.idb_name||"DPP",s=e.storeName||"DPP_Store";this.name="DPP-DB",this.build="2.6",this.buildDate="24 August 2022",this.listeners=new Map,this.logging=t||!1;let o=function(){return!1},a=new r({poolSize:1,logging:n.logging,workerInactivityCheckInterval:n.workerInactivityCheckInterval||60,workerInactivityLimit:n.workerInactivityLimit||60}),l=new Map;for(const[e,t]of handlerCode)l.set(e,a.createUrl(t));a.handlersByMessageType=l;let c=this;this.start=async function(e){let t;if("object"==typeof e&&(e.storeName&&(c.storeName=e.storeName),e.idb_name&&(c.idb_name=e.idb_name),e.auth&&(t=e.auth),e=e.mode),t&&void 0===crypto.subtle){let e="Error: authenticated database access requires https:";return c.logMessage(e),{error:e}}let r={type:"instantiate",idb_name:i,objectStores:[s],qoper8:{auth:t}},n=await a.send(r);return o=function(e,t){e.qoper8||(e.qoper8={}),e.qoper8.token=n.qoper8.token,a.message(e,t)},await(new c.persistAs).proxy(e)};this.persistAs=class{constructor(){this.storeName=s,this.persist=!0}async proxy(e){let t=this,r=(this.storeName,new class{constructor(e,t){return this._preproxy=new WeakMap,this._handler=t,this.proxify(e,[])}makeHandler(e){let t=this;return{set:(r,n,i,s)=>("object"==typeof i&&(i=t.proxify(i,[...e,n])),r[n]=i,t._handler.set&&t._handler.set(r,[...e,n],i,s),!0),deleteProperty(r,n){if(Reflect.has(r,n)){t.unproxy(r,n);let i=Reflect.deleteProperty(r,n);return i&&t._handler.deleteProperty&&t._handler.deleteProperty(r,[...e,n]),i}return!0}}}unproxy(e,t){this._preproxy.has(e[t])&&(e[t]=this._preproxy.get(e[t]),this._preproxy.delete(e[t]));for(let r of Object.keys(e[t]))"object"==typeof e[t][r]&&this.unproxy(e[t],r)}proxify(e,t){for(let r of Object.keys(e))"object"==typeof e[r]&&(e[r]=this.proxify(e[r],[...t,r]));let r=new Proxy(e,this.makeHandler(t));return this._preproxy.set(r,e),r}}({},{async set(e,r,n,i){if(!t.persist)return;c.logMessage("proxy set called with prop = "+JSON.stringify(r));let s=t.receiver,a=!1;function l(t,n){1===t.length&&(e[r]=n),c.emit("save",n),o({type:"put",key:t,value:n})}return r.forEach(function(e,t){s=s[e],a&&(r[t]=[e]),a=Array.isArray(s)}),"object"==typeof n&&async function e(t,r){c.logMessage("getProps called for "+JSON.stringify(t)),c.logMessage("obj="+JSON.stringify(r)),o({type:"delete",key:t});let n=Array.isArray(r);for(let[i,s]of Object.entries(r)){n&&(i=[i]);let r=t.slice();r.push(i),"object"!=typeof s?l(r,s):e(r,s)}}(r,n),["string","number","boolean","symbol","bigint"].includes(typeof n)&&l(r,n),c.emit("proxy_set_completed",r),!0},deleteProperty(e,r){let n=t.receiver,i=!1;r.forEach(function(e,t){n=n[e],i&&(r[t]=[e]),i=Array.isArray(n)}),c.emit("delete",r),o({type:"delete",key:r})}}));return this.receiver=r,"new"!==e?await this.restore():await this.clear(),r}async clear(){let e={type:"restore",storeName:this.storeName,clear:!0};o(e)}async restore(){let e={type:"restore",storeName:this.storeName},t=await(r=e,new Promise(e=>{o(r,function(t){e(t)})}));var r;if(t.error)return this.persist=!1,this.receiver.error=t.error,void(this.persist=!0);this.persist=!1;for(let e in t.obj)this.receiver[e]=t.obj[e];this.persist=!0}}}isEmpty(e){for(const t in e)return!1;return!0}on(e,t){this.listeners.has(e)||this.listeners.set(e,t)}off(e){this.listeners.has(e)&&this.listeners.delete(e)}emit(e,t){if(this.listeners.has(e)){this.listeners.get(e).call(this,t)}}logMessage(e){this.logging&&console.log(Date.now()+": "+e)}};export{DPP};