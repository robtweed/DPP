export async function handler(e,t){let r=this;const o=class{constructor(e){this.name=e}getObjectStore(e){return r.idb.db.transaction(this.name,e).objectStore(this.name)}iterate_db(e,t,r){let o;t||"function"!=typeof e||(t=e,e=null);let n="";e&&(o=IDBKeyRange.lowerBound(e),n=e.toString()+","),this.getObjectStore().openCursor(o).onsuccess=function(o){let i=o.target.result;if(i){let o=i.value;if(e){let e=o.id.toString()+",";""!==n&&e.startsWith(n)?(t&&t(o.id,o.value),i.continue()):r&&"function"==typeof r&&r()}else t&&t(o.id,o.value),i.continue()}else r&&"function"==typeof r&&r()}}iterate(e,t){t||"function"!=typeof e||(t=e,e=null);let r=this;return new Promise(o=>{r.iterate_db(e,t,function(){o()})})}async clearByKey(e){let t=this;await this.iterate(e,async function(e){await t.delete(e)})}clear_db(e){if(!_worker.idb.db)return e({error:"clear() Error: Database has not been opened"});let t=this.getObjectStore("readwrite").clear();t.onsuccess=function(){e({ok:!0})},t.onerror=function(){e({error:t.error})}}clear(){let e=this;return new Promise(t=>{e.clear_db(function(e){t(e)})})}put_item(e,t,o){if(!r.idb.db)return o({error:"addItem Error: Database has not been opened"});o||(o=t,t=e,e=null);let n=this.getObjectStore("readwrite").put(t);n.onsuccess=function(){r.emit("putCommitted",t),o({key:n.result})},n.onerror=function(){o({error:n.error})}}put(e,t){t||(t=e,e=null);let r=this;return new Promise(o=>{r.put_item(e,t,function(e){o(e)})})}delete_item(e,t){if(!r.idb.db)return t({error:"delete_item Error: Database has not been opened"});let o=this.getObjectStore("readwrite").delete(e);o.onsuccess=function(){r.emit("deleteCommitted",e),t({ok:!0})},o.onerror=function(){t({error:o.error})}}delete(e){let t=this;return new Promise(r=>{t.delete_item(e,function(e){r(e)})})}};function n(e,t){let o={};t?o.keyPath=t:o.autoIncrement=!0,r.idb.objectStores.set(e,o)}function i(e,t){if(!r.idb.store)return t({error:"Open Database Error: Store Name not defined"});t||(t=e,e=null);let n=indexedDB.open(r.idb.store,e);n.onsuccess=function(e){r.idb.db=e.target.result,r.emit("databaseOpen",r.idb.db),t({db:r.idb.db})},n.onerror=function(e){t({error:e.target.errorCode})},n.onupgradeneeded=function(e){r.idb.db=e.target.result,function(){if(r.idb)for(const[e,t]of r.idb.objectStores.entries())r.idb.db.objectStoreNames.contains(e)||(r.idb.db.createObjectStore(e,t),r.idb.stores[e]||(r.idb.stores[e]=new o(e)))}()}}async function s(e){return new Promise(t=>{i(e,function(e){t(e)})})}r.idb||(this.idb={objectStores:new Map,stores:{},store:e.storeName});let d=e.objectStores||[];for(const e of d)n(e,"id");await s();let a=!1;for(const e of r.idb.objectStores.keys())r.idb.db.objectStoreNames.contains(e)||(a=!0),r.idb.stores[e]=new o(e);if(a){let e=r.idb.db.version+1;r.idb.db.close(),await s(e),r.emit("databaseReady"),t({db_ready:!0})}else this.emit("databaseReady"),t({db_ready:!0})};