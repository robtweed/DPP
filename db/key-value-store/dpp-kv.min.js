let KV=class{constructor(){this.listeners=new Map,this.transforms={toLowerCase:function(e){return e.toLowerCase()},toString:function(e){return e.toString()},toInteger:function(e){return parseInt(e)},removePunctuation:function(e){return e.replace(/[^\w\s\']|_/g,"").replace(/\s+/g," ")}}}static async start(e){let t=e.index,s=e.logging||!1,i=e.idb_name,r=e.storeName,n=e.QOper8;if(!t||t.transforms||t.props||(t=!1),t&&(t.transforms&&(Array.isArray(t.transforms)||(t.transforms=[t.transforms])),t.props&&(Array.isArray(t.props)||(t.props=[t.props]))),!e.DPP){let{DPP:t}=await import("https://robtweed.github.io/DPP/src/dpp.min.js");e.DPP=t}const o=new KV;let d=await e.DPP.create({idb_name:i,storeName:r,logging:s,QOper8:n});if(o.DPP=d,o.store=await d.start(),o.store.data){(JSON.stringify(t)||"false")!==(JSON.stringify(o.store.indexing)||"false")&&(t?(o.store.indexing=t,t||delete o.store.indexing,o.reIndex()):(delete o.store.index,delete o.store.indexing))}else o.store.data={},t&&(o.store.indexing=t);return o.storeName=r,o}getIndexKey(e){if(this.store.indexing){if("object"==typeof e){if(this.store.indexing.props){let t=[];for(const s in e)if(this.store.indexing.props.includes(s)){let i=this.getIndexKey(e[s]);i&&t.push({prop:s,value:i})}return 0!==t.length&&t}return!1}if(this.store.indexing.transforms)for(const t of this.store.indexing.transforms)this.transforms[t]&&(e=this.transforms[t](e));return e}return!1}addIndex(e,t,s,i){if(this.store.index||(this.store.index={}),void 0===this.store.index[e]&&(this.store.index[e]={}),s){let i={};i[s]=!0,this.store.index[e][t]=i}else this.store.index[e][t]=!0}set(e,t,s){this.store.data[e]=t;let i=this.getIndexKey(t);if(i)if(Array.isArray(i))for(const t of i)this.addIndex(t.value,e,t.prop);else this.addIndex(i,e,null)}get(e){return this.store.data[e]}getByIndex(e,t){let s=[],i=this.getIndexKey(e);if(i)for(const e in this.store.index[i])if(t){let t={key:e,data:this.get(e)};s.push(t)}else s.push(e);return s}search(e,t){let s=[],i=this.getIndexKey(e);if(i)for(const e in this.store.index)if(e.includes(i)){let i=this.getByIndex(e,t);s=s.concat(i)}return s}has(e){return void 0!==this.store.data[e]}deleteIndex(e,t,s,i){s?(delete this.store.index[e][t][s],this.DPP.isEmpty(this.store.index[e][t])&&delete this.store.index[e][t]):delete this.store.index[e][t],this.DPP.isEmpty(this.store.index[e])&&delete this.store.index[e]}delete(e,t){if(this.has(e)){let t=this.getIndexKey(this.get(e));if(t)if(Array.isArray(t))for(const s of t)this.deleteIndex(s.value,e,s.prop);else this.deleteIndex(t,e,null);delete this.store.data[e]}}reIndex(){delete this.store.index;for(const e in this.store.data){let t=this.get(e);this.set(e,t)}}get hasKeys(){for(const e in this.store.data)return!0;return!1}get isEmpty(){return!this.hasKeys}clear(){for(const e in this.store.data)this.delete(e)}dump(){return JSON.stringify(this.store,null,2)}on(e,t){this.listeners.has(e)||this.listeners.set(e,t)}off(e){this.listeners.has(e)&&this.listeners.delete(e)}emit(e,t){if(this.listeners.has(e)){this.listeners.get(e).call(this,t)}}};export{KV};