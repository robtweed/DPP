let KV=class{constructor(){this.listeners=new Map,this.transforms={toLowerCase:function(e){return e.toLowerCase()},toString:function(e){return e.toString()},toInteger:function(e){return parseInt(e)},removePunctuation:function(e){return e.replace(/[^\w\s\']|_/g,"").replace(/\s+/g," ")}}}static async start(e){let t=e.index,s=e.logging||!1,r=e.DPP,i=(e.idb_name,e.storeName),n=e.QOper8,o=e.qOptions;t&&t.transforms&&(Array.isArray(t.transforms)||(t.transforms=[t.transforms]));const a=new KV;let d=new r({storeName:i,logging:s,QOper8:n,qOptions:o});return a.DPP=d,d.start(i),a.store=await new d.persistAs(i).proxy(),a.store.data||(a.store.data={},t&&(a.store.indexing=t,a.store.index={})),a.storeName=i,a}getIndexKey(e){if(this.store.indexing){if("object"==typeof e){if(this.store.indexing.props){let t=[];for(const s in e)if(this.store.indexing.props.includes(s)){let r=this.getIndexKey(e[s]);t.push({prop:s,value:r})}return t}}else if(this.store.indexing.transforms)for(const t of this.store.indexing.transforms)this.transforms[t]&&(e=this.transforms[t](e));return e}}addIndex(e,t,s,r){if(void 0===this.store.index[e]&&(this.store.index[e]={}),s){let r={};r[s]=!0,this.store.index[e][t]=r}else this.store.index[e][t]=!0}set(e,t,s){this.store.data[e]=t;let r=this.getIndexKey(t);if(r)if(Array.isArray(r))for(const t of r)this.addIndex(t.value,e,t.prop);else this.addIndex(r,e,null)}get(e){return this.store.data[e]}getByIndex(e,t){let s=[],r=this.getIndexKey(e);if(r)for(const e in this.store.index[r])if(t){let t={key:e,data:this.get(e)};s.push(t)}else s.push(e);return s}search(e,t){let s=[],r=this.getIndexKey(e);if(r)for(const e in this.store.index)if(e.includes(r)){let r=this.getByIndex(e,t);s=s.concat(r)}return s}has(e){return void 0!==this.store.data[e]}deleteIndex(e,t,s,r){s?delete this.store.index[e][t][s]:delete this.store.index[e][t]}async delete(e,t){if(this.has(e)){let t=this.getIndexKey(this.get(e));if(t)if(Array.isArray(t))for(const s of t)this.deleteIndex(s.value,e,s.prop);else this.deleteIndex(t,e,null);delete this.store.data[e]}}get hasKeys(){for(const e in this.store.data)return!0;return!1}get isEmpty(){return!this.hasKeys}clear(){for(const e in this.store.data)this.delete(e)}dump(){return JSON.stringify(this.store,null,2)}on(e,t){this.listeners.has(e)||this.listeners.set(e,t)}off(e){this.listeners.has(e)&&this.listeners.delete(e)}emit(e,t){if(this.listeners.has(e)){this.listeners.get(e).call(this,t)}}};export{KV};