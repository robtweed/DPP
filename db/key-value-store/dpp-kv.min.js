let KV=class{constructor(){this.listeners=new Map,this.transforms={toLowerCase:function(t){return t.toLowerCase()},toString:function(t){return t.toString()},toInteger:function(t){return parseInt(t)},removePunctuation:function(t){return t.replace(/[^\w\s\']|_/g,"").replace(/\s+/g," ")}}}static async start(t){let e=t.index,s=t.logging||!1,r=t.idb_name,i=t.storeName,n=t.QOper8,o=t.qOptions;if(e&&e.transforms&&(Array.isArray(e.transforms)||(e.transforms=[e.transforms])),!t.DPP){let{DPP:e}=await import("https://robtweed.github.io/DPP/src/dpp.min.js");t.DPP=e}const a=new KV;let d=await t.DPP.create({idb_name:r,storeName:i,logging:s,QOper8:n,qOptions:o});return a.DPP=d,a.store=await d.start(),a.store.data||(a.store.data={},e&&(a.store.indexing=e,a.store.index={})),a.storeName=i,a}getIndexKey(t){if(this.store.indexing){if("object"==typeof t){if(this.store.indexing.props){let e=[];for(const s in t)if(this.store.indexing.props.includes(s)){let r=this.getIndexKey(t[s]);e.push({prop:s,value:r})}return e}}else if(this.store.indexing.transforms)for(const e of this.store.indexing.transforms)this.transforms[e]&&(t=this.transforms[e](t));return t}}addIndex(t,e,s,r){if(void 0===this.store.index[t]&&(this.store.index[t]={}),s){let r={};r[s]=!0,this.store.index[t][e]=r}else this.store.index[t][e]=!0}set(t,e,s){this.store.data[t]=e;let r=this.getIndexKey(e);if(r)if(Array.isArray(r))for(const e of r)this.addIndex(e.value,t,e.prop);else this.addIndex(r,t,null)}get(t){return this.store.data[t]}getByIndex(t,e){let s=[],r=this.getIndexKey(t);if(r)for(const t in this.store.index[r])if(e){let e={key:t,data:this.get(t)};s.push(e)}else s.push(t);return s}search(t,e){let s=[],r=this.getIndexKey(t);if(r)for(const t in this.store.index)if(t.includes(r)){let r=this.getByIndex(t,e);s=s.concat(r)}return s}has(t){return void 0!==this.store.data[t]}deleteIndex(t,e,s,r){s?delete this.store.index[t][e][s]:delete this.store.index[t][e]}async delete(t,e){if(this.has(t)){let e=this.getIndexKey(this.get(t));if(e)if(Array.isArray(e))for(const s of e)this.deleteIndex(s.value,t,s.prop);else this.deleteIndex(e,t,null);delete this.store.data[t]}}get hasKeys(){for(const t in this.store.data)return!0;return!1}get isEmpty(){return!this.hasKeys}clear(){for(const t in this.store.data)this.delete(t)}dump(){return JSON.stringify(this.store,null,2)}on(t,e){this.listeners.has(t)||this.listeners.set(t,e)}off(t){this.listeners.has(t)&&this.listeners.delete(t)}emit(t,e){if(this.listeners.has(t)){this.listeners.get(t).call(this,e)}}};export{KV};