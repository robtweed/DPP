let LIST=class{constructor(){this.listeners=new Map}static async start(e){let t=e.logging||!1,o=e.idb_name,n=e.storeName,r=e.QOper8;if(!e.DPP){let{DPP:t}=await import("https://robtweed.github.io/DPP/src/dpp.min.js");e.DPP=t}const s=new LIST;let d=await e.DPP.create({idb_name:o,storeName:n,logging:t,QOper8:r});return s.DPP=d,s.store=await d.start(),d.isEmpty(s.store)&&(s.store.nextNodeNo=0,s.store.count=0,s.store.node={}),s.storeName=n,s}rpush(e){if(!e)return!1;let t=this.store,o=0===t.count,n=t.nextNodeNo+1;if(t.nextNodeNo=n,t.count++,t.node||(t.node={}),t.node[n]={},t.node[n].content=e,o)t.firstNode=n,t.lastNode=n;else{let e=t.lastNode;t.lastNode=n,t.node[n].previousNode=e,t.node[e].nextNode=n}return n}lpush(e){if(!e)return!1;let t=this.store,o=0===t.count,n=t.nextNodeNo+1;if(t.nextNodeNo=n,t.count++,t.node||(this.store.node={}),t.node[n]={},t.node[n].content=e,o)t.firstNode=n,t.lastNode=n;else{let e=t.firstNode;t.firstNode=n,t.node[n].nextNode=e,t.node[e].previousNode=n}return n}get rpop(){let e=this.store;if(this.DPP.isEmpty(e))return{};if(0===e.count)return{};let t=e.lastNode;if(!e.node[t])return{};let o=e.node[t].content,n=e.count;if(1===n)e.count=0,e.nextNodeNo=0,delete e.node,delete e.firstNode,delete e.lastNode;else{let o=e.node[t].previousNode;e.lastNode=o,delete e.node[o].nextNode,delete e.node[t],e.count=n-1}return o}get lpop(){let e=this.store;if(this.DPP.isEmpty(e))return{};if(0===e.count)return{};let t=e.firstNode;if(!e.node[t])return{};let o=e.node[t].content,n=e.count;if(1===n)e.count=0,e.nextNodeNo=0,delete e.node,delete e.firstNode,delete e.lastNode;else{let o=e.node[t].nextNode;e.firstNode=o,delete e.node[o].previousNode,delete e.node[t],e.count=n-1}return o}lrange(e,t){let o=this.store,n=[];if(this.DPP.isEmpty(o))return n;if(0===o.count)return n;void 0!==e&&void 0===t&&(t=e),void 0===e&&(e=0),void 0===t&&(t=-1);let r=-1;function s(s){return++r>=e&&n.push(o.node[s].content),t!==r&&s!==o.lastNode&&o.node[s].nextNode}let d=o.firstNode;for(;d;)d=s(d);return n}ltrim(e,t){let o=this.store;if(this.DPP.isEmpty(o))return!1;if(0===o.count)return!1;void 0!==e&&void 0===t&&(t=e),void 0===e&&(e=0),void 0===t&&(t=-1);let n=-1;function r(e){let t=o.node[e].previousNode,n=o.node[e].nextNode;return delete o.node[e],o.count=o.count-1,t&&n?(o.node[t].nextNode=n,void(o.node[n].previousNode=t)):t||n?t?(o.lastNode=t,void delete o.node[t].nextNode):(o.firstNode=n,void delete o.node[n].previousNode):(delete o.firstNode,void delete o.lastNode)}function s(s){n++;let d=o.node[s].nextNode;return n<e?(r(s),0!==o.count&&d):-1!==t&&n>t?(r(s),0!==o.count&&d):s!==o.lastNode&&d}let d=o.firstNode;for(;d;)d=s(d);return!0}count(){return this.store.count}get length(){return this.store.count}get isEmpty(){return 0===this.length}insertBefore(e,t){if(!e)return!1;if(!t)return this.lpush(e);let o=this.store;if(this.DPP.isEmpty(o))return this.rpush(e);let n=this.getMemberId(t);if(!n)return this.rpush(e);let r=o.nextNodeNo+1;o.nextNodeNo=r,o.count=o.count+1,o.node||(this.store.node={}),o.node[r]={},o.node[r].content=e,o.node[r].nextNode=n;let s=o.node[n].previousNode;return s?(o.node[n].previousNode=r,o.node[r].previousNode=s,o.node[s].nextNode=r):o.firstNode=r,r}getMemberId(e){let t=this.store;if(this.DPP.isEmpty(t))return!1;if(0===t.count)return!1;if(t.count<e)return!1;let o=-1,n=!1;function r(r){return e===++o?(n=r,""):r===t.lastNode?"":t.node[r].nextNode}let s=t.firstNode;for(;""!==s;)s=r(s);return n}clear(){let e=this.length+1;this.ltrim(e,-1),this.store.nextNodeNo=0}dump(){return JSON.stringify(this.store,null,2)}on(e,t){this.listeners.has(e)||this.listeners.set(e,t)}off(e){this.listeners.has(e)&&this.listeners.delete(e)}emit(e,t){if(this.listeners.has(e)){this.listeners.get(e).call(this,t)}}};export{LIST};